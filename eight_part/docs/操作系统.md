# 操作系统
> 操作系统是一种软件，提供了几种抽象模型：
> - 文件：对IO设备的抽象
> - 虚拟内存：对程序存储器的抽象
> - 进程：对一个正在运行的程序的抽象
> - 虚拟机：对整个操作系统的抽象

## 1. 操作系统概念
### 1.1 计算机硬件介绍
CPU、内存、IO设备、总线串联并，通过控制器与其他设备进行通信。
> CPU中包含MMU，即Memory Management Unit，内存管理单元。MMU的主要功能是提供虚拟地址和物理地址的转换。

- **CPU**：CPU的执行周期是从内存中提取、解码（决定操作类型和操作数）、执行，并循环。CPU中包含一些**寄存器**保存关键变量和内存结果。

  **寄存器**
  - 程序计数器：指向下一条指令的地址。
  - 堆栈指针：内存中当前栈的顶端。
  - PSW：程序状态字寄存器，8B，跟踪当前状态，在系统调用中起作用。有用户态和内核态指示，系统调用通过TRAP指令切换内核态。
  
  **CPU执行**
  - pipeline流水线：取指-解码-执行；
  - 超标量CPU：在解码和执行之间增加了缓冲区，硬件负责保证运算顺序。

- 内存
  - 多级内存方案
    - 寄存器：存储器的顶层，和CPU一样快
    - cache：主存被封为cache lines，读取时先读缓存。缓存存在一些问题。
      - 何时放入缓存
      - 新内容放在哪里
      - 如何移除
      - 移除后放在哪里
    - 主存
    - 磁盘：磁头，磁盘臂，柱面，磁道，扇区
      > 固态硬盘不是磁盘，数据存储在闪存中 
  - 虚拟内存：内存映像机制，由MMU完成。

- IO设备

  一般包含两个部分，**设备控制器**和**设备本身**。

  设备控制器有设备驱动程序，设备驱动程序装入OS的方法：
  - 内核与设备启动程序重新连接，重启（UNIX）
  - 操作系统文件中设置一个入口，重启系统会装载。
  - 运行时驱动程序。

  实现输入输出的方式：
  - 程序直接控制，设备驱动程序启动IO并循环检查，看是否完成了工作。忙等待，轮训，一直占据CPU。
  - 中断，CPU和IO并行工作。
  - DMA直接存储器访问，彻底释放CPU。
  - 通道控制，CPU、通道和IO并行操作。

- 总线
- 计算机启动过程
  
  1. BIOS开启，自检。检查RAM数量，键盘和其他基础设备是否安装，扫描PCIe和PCI总线并连接设备。
  2. 启动设备选择。
  3. 引导程序加载，BIOS读取该设备引导扇区（其中存储了引导程序），引导程序的作用是加载OS的核心部分到内存中，

### 1.2 操作系统概念
- 进程Process：进程的本质是操作系统执行的程序，进程有地址空间。进程可以在地址空间进行读写，地址空间包括可执行程序、数据和栈。进程还有资源集，如寄存器（程序计数器和堆栈指针）、打开文件清单、进程清单。
  - 进程拥有的资源
    - 内存空间
    - 处理器状态，如PC、寄存器值、指令指针
    - 打开的文件和设备
    - 文件控制块
    - 文件描述符表
    - 进程优先级
- 文件保护：rwx文件保护。使用0-7表示rwx。
  - r：4
  - w：2
  - x：1
  - rwxr-x--x：751
  
## 2. 进程和线程
### 2.1 进程
- 进程模型
  
  进程是某一类特定活动的总和，有程序、输入输出和状态，程序是写死的，进程是活的。

- 进程的创建
  - 系统初始化：前台进程（用户交互），后台进程（守护进程）
  - 系统调用：系统调用创建新进程
  - 用户请求：
  - 批处理：fork创建副本，在fork后，一个父进程和子进程会有相同的内存映像，子进程会执行execve或者一个简单的系统调用来改变内存映像并运行一个新的程序。
- 进程的终止
  - 正常退出
  - 错误退出
  - 严重退出：如mod 0，中断
  - 被其他进程杀死
- 进程的层次结构
  - unix中，进程和所有子进程（递归）构成一个进程组。用户从键盘发出信号，信号被发送到所有进程组成员，进程可以分别捕获、忽略或采取默认动作。
  - 整个操作系统中的所有进程都属于单个以init为根的进程树。
- 进程状态
  - 运行：进程实际占用 CPU 时间片运行时
  - 就绪：可运行，但因为其他进程正在运行而处于就绪状态
  - 阻塞：除非某种外部事件发生，否则进程不能运行
- 进程的实现
  - 进程表
    - 程序计数器
    - 堆栈指针
    - 内存分配
    - 优先级
    - 调度参数
    - 进程ID
    - 父进程
    - 信号
    - 时间信息
- 中断处理和调度过程
  - 1. 硬件 压入堆栈程序计数器
  - 2. 硬件 从中断向量装入
  - 3. 汇编语言过程 保存寄存器的值
  - 4. 汇编语言过程 设置新的堆栈
  - 5. C 中断服务器运行（典型的读和缓存写入）
  - 6. 调度器 决定下面哪个程序先运行
  - 7. C 汇编语言过程 保存寄存器的值
  - 8. 汇编语言过程 开始运行新的当前过程

### 2.2 线程
- 线程的使用
  - 多线程之间共享同一块地址空间和数据
  - 线程比进程更轻量级，由于更轻，所以比进程更容易创建，也更容易撤销
  - 如果多个线程是CPU密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的 I/O 处理，拥有多个线程能在这些活动中彼此重叠进行，从而会加快应用程序的执行速度
- 经典的线程模型
  
  理解进程的另一个角度：用某种方法把相关的资源集中在一起。进程有存放程序正文和数据以及其他资源的地址空间。这些资源包括打开的文件、子进程、即将发生的定时器、信号处理程序、账号信息等。把这些信息放在进程中会比较容易管理。

  - 线程持有哪些资源？
    - 程序计数器
    - 寄存器
    - 堆栈
    - 状态
  - 线程是CPU调度执行的实体
  - 线程的状态
    - 运行中
    - 阻塞
    - 就绪
    - 终止
- POSIX线程
  
  POSIX线程（通常称pthreads）是一种独立于语言存在的执行模型，以及并行模型，允许程序控制**时间上重叠的多个不同的工作流程**。每个流程都称为一个线程。
- 线程实现
  - 用户空间线程
    - 整个线程放在用户空间中，内核维护进程表。线程表由运行时环境runtime system统一管理。
    - 优势：保存线程的状态和调度都是本地过程，上下文切换效率高。允许自己的调度算法。
    - 劣势：阻塞系统调用实现困难。如缺页故障，会将整个进程阻塞直到磁盘IO完成为止。
  - 内核空间线程
    - 系统调用代价较大
  - 用户和内核空间混合线程
    - 内核级线程，多个用户线程对应一个内核线程，多路复用

### 2.3 进程间通信
进程间通信Inter Process Communication的几个关键问题：
- 进程如何传递消息给其他进程：共享地址空间
- 多个线程之间不互相干扰
- 先后顺序

**一些相关概念**
- 竞态条件：两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性
- 临界区：禁止一个或多个进程在同一时刻对共享资源进行读写
- 忙等互斥
  - 屏蔽中断：进程进入临界区后屏蔽所有中断。屏蔽中断后，时钟中断也会被屏蔽。CPU 只有发生时钟中断或其他中断时才会进行进程切换。这样，在屏蔽中断后 CPU 不会切换到其他进程。所以，一旦某个进程屏蔽中断之后，它就可以检查和修改共享内存，而不用担心其他进程介入访问共享数据。（对于操作系统本身来说是一项很有用的技术，但是对于用户线程来说，屏蔽中断却不是一项通用的互斥机制）
  - 锁变量
  - 轮训机制
  - Peterson方法：锁变量与警告变量相结合，不需要严格轮换
- 睡眠与唤醒
  - 生产者-消费者问题：共享缓冲区
- 信号量机制semaphore：检查信号量是否大于0
- 互斥量mutex
  - 同步和锁定
  - 自旋锁spin lock
  > 从实现原理上来讲，Mutex（互斥锁）属于**sleep-waiting**类型的锁。例如在一个双核的机器上有两个线程（线程A和线程B）,它们分别运行在Core0和Core1上。假设线程A想要通过pthread_mutex_lock操作去得到一个临界区的锁，而此时这个锁正被线程B所持有，那么线程A就会被阻塞，Core0会在此时进行上下文切换(Context Switch)将线程A置于等待队列中，此时Core0就可以运行其它的任务而不必进行忙等待。而Spin lock（自旋锁）则不然，它属于busy-waiting类型的锁，如果线程A是使用pthread_spin_lock操作去请求锁，那么线程A就会一直在Core0上进行忙等待并不停的进行锁请求，直到得到这个锁为止。
  > 自旋锁与互斥锁有点类似，只是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，“自旋锁”的作用是为了**解决某项资源的互斥使用**。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。
  > 自旋锁一直占用着CPU，他在未获得锁的情况下，一直运行（自旋），所以占用着CPU，如果不能在很短的时间内获得锁，这无疑会使CPU效率降低。

- 管程
- 消息传递
- 屏障：用于进程组而不是进程间的生产者-消费者情况

### 2.4 调度
上下文切换需要干什么：内存映射、清除、重新调入高速缓存
- 先来先服务
- 最短作业优先
- 最短剩余时间优先
- 轮询
- 优先级调度
- 多级队列
  
## 3. 内存管理
### 3.1 无存储器抽象
最早的存储器抽象是无存储器，每一个程序都能直接访问物理内存。内存模型就是物理内存。此时不能同时运行两个应用程序。

物理内存暴露给进程的缺点：
- 容易破坏操作系统
- 难以运行多个程序

### 3.2 地址空间
- 地址空间的概念：多个应用程序运行在内存中，必须解决两个问题：保护和重定位。
  - 保护密钥标记内存块
  - 创建存储器抽象——地址空间：地址空间是可用于寻址的地址集，每个进程都有自己的地址空间，独立于其他进程。某些进程可以共享地址空间。
- 基址寄存器：存储数据内存的起始位置
- 变址寄存器：存储应用程序的长度
  - 每当进程引用内存获取指令时，CPU将基址值添加到进程生成的地址中，然后再发送到内存总线上。同时，检查程序提供的地址是否超出变址寄存器的值。
- 使用基址寄存器和变址寄存器每次访问内存时都需要进行ADD和CMP运算，相比于CMP，ADD计算更慢。
- **交换技术**：进程所需要的RAM容量远高于内存容量。
  - swapping交换技术：进程完整调入内存，运行一段时间再放回磁盘，空闲进程存储在磁盘中；
  - 虚拟内存：每个程序都有自己的地址空间，地址空间被划分为多个page，每一个page都是连续的地址范围。这些page被映射到物理内存，缺失部分调入。
    - 使用虚拟内存可以将地址空间以很小的单位映射到物理内存中，而不是只针对text和data区进行重定位。
- **空闲内存管理**：
  - 位图：内存被划分为分配单元，每个分配单元对应位图中的一位。
    - 优点：简单
    - 缺点：内存管理器搜索位图，找到连续k个0位困难。
  - 空链表
    - 首次适配
    - 上次适配
    - 最佳适配
    - 最差适配
    - 快速适配
### 3.3 虚拟内存
- 分页
  - 没有虚拟内存的计算机上，直接将虚拟地址送到内存中线上
  - 有虚拟内存时，使用MMU将虚拟地址映射为物理地址
  - 页表：给出了虚拟地址和物理地址的映射关系。
  - 未映射的页如何映射？
    - 缺页中断，trap
- ![[1612665410-HVwgLy-os3-17.png]]

![[1612665424-wOBTTK-os3-19.png]]

- 页表
  - 虚拟地址分为虚拟页号（高位部分）和偏移量（地位部分）。虚拟页号可作为页表的**索引**用来找到虚拟页中的内容。由页表项可以找到页框号（如果有的话）。然后把页框号拼接到偏移量的高位端，以替换掉虚拟页号，形成物理地址。
  - 页表的目的：虚拟页号->页框号
- 加速分页过程
  - 分页系统面临的问题：
    - 虚拟地址到物理地址的映射速度必须快
    - 虚拟地址空间足够大，页表也会足够大
      - 页表太大时上下文切换加载页表
  - 针对映射速度：转换检测缓冲区 TLB
    - 一种内存缓存，通常位于CPU和Cache之间。
    - TLB失效
  - 针对大内存的页表
    - 多级页表
    - 倒排页表：每个页框对应一个表项
- 页面置换算法
  - 最优页面置换算法（理想情况，难以实现）
  - 最近未使用 NRU
    - 出现缺页中断后，操作系统会检查所有的页面，并根据它们的 R 位和 M 位将当前值分为四类：

    第 0 类：没有引用 R，没有修改 M
    第 1 类：没有引用 R，已修改 M
    第 2 类：引用 R ，没有修改 M
    第 3 类：已被访问 R，已被修改 M

  - 先进先出FIFO
  - 第二次机会页面置换：在最近的时钟间隔中未被访问的页面，如果都被访问过，退化为FIFO
  - 时钟页面置换算法
  - 最近最少未使用 LRU
  - 工作集页面置换算法：预先调页
  
- 总结
  | 算法         | 注释                                                         |
| ------------ | ------------------------------------------------------------ |
| 最优算法     | 不可实现，但可作为基准                                       |
| NRU(最近未使用) 算法 | 与 LRU 算法相似                                             |
| FIFO(先进先出) 算法 | 有可能会抛弃重要的页面                                       |
| 第二次机会算法 | 比 FIFO 有较大的改善                                         |
| 时钟算法     | 实际使用                                                     |
| LRU(最近最少)算法 | 较优秀，但很难实现                                           |
| NFU(最不经常使用)算法 | 与 LRU 类似                                                 |
| 老化算法     | 近似 LRU 的高效算法                                         |
| 工作集算法   | 实施起来开销很大                                             |
| 工作集时钟算法 | 比较有效的算法                                               |

- 最优算法在当前页面中置换最后要访问的页面。不幸的是，没有办法来判定哪个页面是最后一个要访问的，因此实际上该算法不能使用。然而，它可以作为衡量其他算法的标准。
- NRU 算法根据 R 位和 M 位的状态将页面分为四类。从编号最小的类别中随机选择一个页面。NRU 算法易于实现，但性能不佳。存在更好的算法。
- FIFO 会跟踪页面加载进入内存中的顺序，并把页面放入一个链表中。有可能删除存在时间最长但仍在使用的页面，因此这个算法也不是一个很好的选择。
- 第二次机会算法是对 FIFO 的一个修改，它会在删除页面之前检查这个页面是否仍在使用。如果页面正在使用，就会进行保留。这个改进大大提高了性能。
- 时钟算法是第二次机会算法的另一种实现形式，性能与第二次机会算法相近，但执行时间更少。
- LRU 算法是一个非常优秀的算法，但没有特殊的硬件(TLB)很难实现。如果没有硬件，就不能使用 LRU 算法。
- NFU 算法是一种近似于 LRU 的算法，性能不是很好。
- 老化算法是一种更接近 LRU 算法的实现，并且可以更好地实现，因此是一个很好的选择。
- 最后两种算法都使用了工作集算法。工作集算法提供了合理的性能开销，但实现比较复杂。WSClock 是另一种变体，不仅能提供良好的性能，而且能高效实现。

总之，最好的算法是老化算法和WSClock算法。它们分别基于 LRU 和工作集算法。它们都具有良好的性能并且能够被有效实现。还有其他一些好的算法，但实际上这两个可能是最重要的。

## 4. 文件系统
### 4.1 文件
文件是由进程创建的逻辑信息单元。存储在文件上的信息必须是持久的。文件由OS进行管理，OS中处理文件的部分被称为文件系统。

- 文件结构
  - 字节序列
  - 记录序列：文件是具有固定长度记录的序列，每个记录都有其内部结构。读操作返回一个记录，写操作重写或追加一个记录。
  - 树：可以按key快速查找。
- 文件类型
  - 常规文件
  - 字符特殊文件
  - 块特殊文件
- 文件访问
  - 序列访问
  - 随机访问
    - read从头开始读
    - seek设置当前位置

### 4.2 目录
- 层级目录系统 Hierarchical Directory System 目录树

### 4.3 文件系统的实现
- 文件系统布局
  文件系统存储在磁盘中，大部分磁盘能够划分出一个到多个分区，每个分区都有独立的文件系统。
  - 0号分区：主引导记录，MBR
  - MBR的结尾：分区表，给出分区从开始到结束的地址
  - 引导块：MBR的第一个块，引导块中的程度负责加载分区中的操作系统；
  - 超级块：文件系统的所有关键参数，如文件系统大小、数据块数、文件系统状态标志、分配组大小
  - 空闲空间管理：bitmap或者链表
  - inode：索引节点
- 文件的实现：记录各个文件分别用到了哪些磁盘块，主要思想是**有效利用文件空间**和**快速访问文件**。
  - 连续分配：简单，高性能，但是磁盘碎片。
  - 链表分配：顺序方便，随机困难
  - inode：索引节点，每个文件都与一个 inode 进行关联，inode 由整数进行标识。inode 的一个问题是如果每个节点都会有固定大小的磁盘地址，那么文件增长到所能允许的最大容量外会发生什么？一个解决方案是最后一个磁盘地址不指向数据块，而是指向一个包含额外磁盘块地址的地址。
- 目录的实现
- 共享文件
  - 有向无环图DAG
- 日志结构文件系统
- 日志文件系统
- 虚拟文件系统
  
### 4.4 文件系统的管理和优化
- 磁盘空间管理
- 文件系统备份
- 一致性：
## 5. 输入和输出
## 6. 死锁

## 7. 面试题
# MySQL
## 0. 什么是MySQL？
开源关系型数据库管理系统，属于Oracle旗下。

## 1. 什么是内连接、外连接、交叉连接、笛卡尔积？
- 内连接：取得两张表中满足存在连接匹配关系的记录。
- 外连接：不只取得两张表中满足存在连接匹配关系的记录，还包括某张表（或两张表）中不满足匹配关系的记录。
- 交叉连接：显示两张表的所有记录一一对应，没有匹配关系筛选。它是笛卡尔积在 SQL 中的实现，如果 A 表有 m 行，B 表有 n 行，那么 A 和 B 交叉连接的结果就有 m*n 行。
- 笛卡尔积：是数学中的一个概念，例如集合 A={a,b}，集合 B={0,1,2}，那么 A✖️B={<a,0>,<a,1>,<a,2>,<b,0>,<b,1>,<b,2>,}。

## 2. MySQL 的内连接、左连接、右连接有什么区别？
MySQL的连接可以分为内连接和外连接，外连接又可以分为左连接和右连接。
- inner join：内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集。
只有当两个表中都有匹配的记录时，这些记录才会出现在查询结果中。如果某一方没有匹配的记录，则该记录不会出现在结果集中。
- left join：返回左表的所有记录，以及右表的匹配记录。如果右表中没有匹配的记录，则结果中右表的部分会以 NULL 填充。
- right join：返回右表的所有记录，以及左表的匹配记录。如果左表中没有匹配的记录，则结果中左表的部分会以 NULL 填充。
```sql
-- 返回了至少有一条评论的文章标题和评论内容的前 20 个字符，限制结果为前 2 条记录
SELECT LEFT(a.TITLE, 20) AS ArticleTitle, LEFT(c.content, 20) AS ComentContent
FROM article a
INNER JOIN comment c ON a.ID = c.articleID
LIMIT 2;
```

```sql
-- 返回了所有文字的标题和评论内容的前 20 个字符，即使某些文章没有评论，限制结果为前 2 条记录
SELECT LEFT(a.TITLE, 20) AS ArticleTitle, LEFT(c.content, 20) AS ComentContent
FROM article a
LEFT JOIN comment c ON a.ID = c.articleID
LIMIT 2;
```

```sql
SELECT LEFT(a.TITLE, 20) AS ArticleTitle, LEFT(c.content, 20) AS ComentContent
FROM comment c
RIGHT JOIN article a ON a.ID = c.articleID
LIMIT 2;
```

## 3. 数据库的三大范式
- 第一范式：数据库表中的每一列（每个字段都不可再分），保持原子性；
- 第二范式：在第一范式的基础上，非主键列完全依赖于主键。比如，订单列表里，存储了商品信息（商品价格、商品类型），那就需要把商品 ID 和订单 ID 作为联合主键，才满足第二范式。
- 第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键列。
- 
三大范式的作用是为了控制数据库的冗余，是对空间的节省，实际上，一般互联网公司的设计都是反范式的，通过冗余一些数据，避免跨表跨库，利用空间换时间，提高性能。

## 4. varchar和char的区别
- char
  - 定长字符串；
  - 小于固定长度，空格填充；
  - 因为是定长，读取速度比varchar快，空间换时间；
  - 最多能存放255个字符；
- varchar
  - 变长字符串；
  - 存储空间由实际字符长度决定；
  - 读取速度比char慢，时间换空间；
  - 最多能存放65535个字符；

## 5. blob和text的区别
- blob存储二进制数据（按照字节顺序进行排序和比较），text存储字符串（按照字符集进行排序和比较）
- blob 没有字符集，text 有一个字符集，并且根据字符集的校对规则对值进行排序和比较
> 拓展：MYSQL如何对汉字进行排序？
> 在MySQL中，你可以使用 COLLATE 关键字来指定排序规则。例如，如果你希望按照拼音对汉字进行排序，可以使用 utf8mb4_unicode_ci 或 utf8mb4_general_ci 排序规则：
> ```mysql
> SELECT * FROM your_table ORDER BY your_column COLLATE utf8mb4_unicode_ci;
> ```
> 原理基本上是将汉字转换成拼音或者其他字符序列。

## 6. DATETIME和TIMESTAMP的异同
**相同点**：
1. 两个数据类型存储时间的表现格式一致。均为 YYYY-MM-DD HH:MM:SS
2. 两个数据类型都包含「日期」和「时间」部分。
3. 两个数据类型都可以存储微秒的小数秒（秒后 6 位小数秒）

**区别**：
- 日期范围：DATETIME 的日期范围是 1000-01-01 00:00:00.000000 到 9999-12-31 23:59:59.999999；TIMESTAMP 的时间范围是1970-01-01 00:00:01.000000 UTC 到 ``2038-01-09 03:14:07.999999 UTC（为什么是2038，因为存储空间限制为4字节，即32位，能存储的整数最大为2^31-1，即2147483647秒，导致了对时间范围的限制）
- 存储空间：DATETIME 的存储空间为 8 字节；TIMESTAMP 的存储空间为 4 字节
- 时区相关：DATETIME 存储时间与时区无关；TIMESTAMP 存储时间与时区有关，显示的值也依赖于时区
- 默认值：DATETIME 的默认值为 null；TIMESTAMP 的字段默认不为空(not null)，默认值为当前时间(CURRENT_TIMESTAMP)

## 7. MySQL 中 in 和 exists 的区别
MySQL 中的 in 语句是把**外表和内表作hash连接**，而 exists 语句是对**外表作loop循环**，每次 loop 循环再对内表进行查询。我们可能认为 exists 比 in 语句的效率要高，这种说法其实是不准确的，要区分情景。EXIST是一个子查询谓词，用于检测子查询的返回值是否为空（只用找到一个记录）。
- 如果查询的两个表大小相当，那么用 in 和 exists 差别不大。
- 如果两个表中一个较小，一个是大表，则子查询表大的用 exists，子查询表小的用 in。
- not in 和 not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而 not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用 not exists 都比 not in 要快。

**hash连接的原理**：首先对外部查询的表和子查询的结果集进行哈希处理，然后将它们的哈希值进行比较，以确定是否存在匹配的行。通常用于一个表小，一个表大的情况。

## 8. MySQL 里记录货币用什么字段类型比较好
- 不用float或者double：二进制存储，有一定误差
- 用decimal或者numeric：字符串存储，定点数，精度高，但是存储空间大，可以制定精度
  
## 9. MySQL如何存储emoji😈
可以直接用字符串存储emoji。但是因为mysql的utf8是阉割版的utf8，最多只用三个字节，存储不了表情。
可以用utf8mb4编码。
```sql
alter table blogs modify content text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci not null;
```

## 10. drop、delete 与 truncate 的区别
| 类型      | 属于      | 回滚    | 删除内容                       | 删除速度     |
|----------|-----------|---------|--------------------------------|--------------|
| delete   | DML       | 可回滚  | 表结构还在，删除表的全部或者一部分数据行  | 删除速度慢，需要逐行删除  |
| truncate | DDL       | 不可回滚| 表结构还在，删除表中的所有数据     | 删除速度快   |
| drop     | DDL       | 不可回滚| 从数据库中删除表，所有数据行，索引和权限也会被删除 | 删除速度最快 |

因此，在不再需要一张表的时候，用 drop；在想删除部分数据行时候，用 delete；在保留表而删除所有数据的时候用 truncate。

## 11. UNION和UNION ALL的区别
- UNION：对两个结果集进行并集操作，表连接后筛选掉重复的记录行；（自动去重）
- UNION ALL：不去重。
- 从效率上说，UNION ALL 要比 UNION 快很多，如果合并没有刻意要删除重复行，那么就使用 UNION All

## 12. count(1)、count(*) 与 count(列名) 的区别
- count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为 NULL
- count(1)包括了忽略所有列，用 1 代表代码行，在统计结果的时候，不会忽略列值为 NULL
- count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者 0，而是表示 null）的计数，即某个字段值为 NULL 时，不统计。

**执行速度**：
- 列名为主键，count(列名)会比 count(1)快（因为有索引）
- 列名不为主键，count(1)会比 count(列名)快
- 如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*）
- 如果有主键，则 select count（主键）的执行效率是最优的
- 如果表只有一个字段，则 select count（*）最优。

## 13. 一条SQL语句的执行顺序

## 数据库架构

## 存储引擎

## SQL优化

## 索引

## 锁

## 事务

## 高可用/性能

## 运维
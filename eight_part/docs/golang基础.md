# 八股文
## 基础
1. 与其他语言相比，go语言的好处？
	- 可读性高，使用了单一的标准编码格式
	- 针对并发进行优化，从语言上支持并发
	- 自动垃圾回收
2. golang数据类型
	bool/int/int64/string/array/slice/struct/pointer/function/interface/map/channel
## map
## channel
# 并发
## GMP调度模型

## 垃圾回收
1. 垃圾回收的概念
	垃圾回收就是对程序中不再使用的内存资源进行自动回收。
2. 常见的垃圾回收算法
- 引用计数：每个对象维护一个引用计数，创建或者被赋值给其他对象时引用计数+1，被销毁则-1，计数为0时回收对象。
	- 优点：对象可以很快被回收，不会出现内存耗尽或者到达阈值才回收。
	- 缺点：不能很好的处理循环引用。
- 复制算法：内存分为两个区，From和To。垃圾回收过程将From区域存活的对象复制到To区域，并按照顺序排列，不会产生内存碎片。
- 标记-清除：标记阶段，从根变量开始，通过可达性分析，遍历所有引用对象，引用对象标记为被引用，没有标记的则进行回收。清除阶段，遍历整个堆内存，回收未被标记的对象。
	- 优点：处理了循环引用。
	- 缺点：需要stop-the-world，暂停程序运行，可能会产生内存碎片。
- 标记-整理：结合了标记-清除和复制算法的思想。整理阶段直接在源空间进行对象移动。
- 分代收集：按照对象生命周期长短划分为不同代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率。
	- 优点：回收性能好。
	- 缺点：算法复杂。

3. 三色标记法：

# 面试题
 `t *testing.T`
 **defer return panic执行顺序**
- 函数内多个defer的执行顺序是先入后出（入栈）
- panic先于defer执行，不然defer函数内部补货不到错误
- panic执行后，后续逻辑return没有执行
- defer中可以修改返回值，注意：前提是函数的返回值不是匿名的
函数返回的是匿名参数 defer无法修改
函数中有panic匿名的返回值是nil，return复制得不到执行，defer修改不到返回值
return的步骤：
- return先执行，将结果写入返回值（赋值）
- defer进行收尾工作，函数携带当前返回值退出
**panic defer recover执行顺序**


for range循环时会创建每个元素的副本，而不是每个元素的引用
for range 循环的时候会创建每个元素的副本，而不是元素的引用， 所以 m[key] = &val 取的都是变量 val 的地址，所以最后 map 中的所有元素的值都是变量 val 的地址， 因为最后 val 被赋值为3，所有输出都是3.

make如果输入值，会默认给其初始化默认值

在函数有多个返回值时，只要有一个返回值有命名， 其他的也必须命名。如果有多个返回值必须加上括号()； 如果只有一个返回值且命名也必须加上括号()。
**new和make的区别**
new只初始化并返回指针，make不仅要初始化，还要设置数组长度、容量等。
```go
func main() {
	list := new([]int)
    // 编译错误
    // new([]int) 之后的 list 是一个未设置长度的 *[]int 类型的指针
    // 不能对未设置长度的指针执行 append 操作。
	list = append(list, 1)
	fmt.Println(list)

	s1 := []int{1, 2, 3}
	s2 := []int{4, 5}
    // 编译错误，s2需要展开
	s1 = append(s1, s2)
	fmt.Println(s1)
}
```
含有map/slice类型的struct不能比较
通过指针变量p访问成员变量name的方式
p.name / (* p).name
golang单引号内容表示单个字符rune，反引号内容表示不可转义的字符串
golang iota
匿名变量 跳过值 显式赋值 iota下一个值
var赋值
nil是一个预定义标识符，标识指针、接口、切片、映射、通道和函数的零值，而不是字符串的零值。赋给字符串时不合法的
var x interfance{}=nil 接口变量可以持有任何类型的值
var x err=nil 错误的零值
var x string=nil 不可发
var x=nil var关键字需要显式制定类型

channel
写chan时，<-右端必须要有值

可变参数传递 指针传递
整形与浮点形不能相加

切片相关
s[a:b:b] 创建切片s从a开始，到4结束，容量为1
对切片切割时key制定切片的容量，s[low:high:max]，
- `low` 是切片的起始索引（包含）。
- `high` 是切片的结束索引（不包含）。
- `max` 是切片的最大容量（切片的底层数组中允许的最大元素数量），但是不能超过slice长度。
操作符 [i:j:k]，k 主要是用来限制切片的容量， 但是不能大于数组的长度 ，截取得到的切片长度和容量计算方法是 j-i、k-i
s[a:b]会自动推断容量
数组由数组中的值和长度两部分组成，如果长度不同，两个数组属于不同类型，不能进行比较

cap（）函数 capacity
array slice channel（map不可以）
array返回数组中元素个数，slice返回slice最大容量，channel返回channel容量

当且仅当接口的动态值和动态类型都为 nil 时，接口类型值才为 nil。

删除map不存在的键值对时，不会报错，相当于没有任何作用。
获取不存在的键值对时，返回类型对应零值。

%+d 是带符号输出

自定义一个全局字符变量
 var str string
 var str = ""

```go
func f(i int) {
	fmt.Println(i)
}
func Test22(t *testing.T) {
	i := 5
	defer f(i)
	i = i + 10
}
```
f() 函数的参数在执行 defer 语句的时候会保存一份副本， 在实际调用 f() 函数时用，所以是 5.

Go中的字符串是只读的

nil切片和空切片不相等

iota 在 const 关键字出现时将被重置为0，const中每新增一行常量声明将使 iota 计数一次。

go 中的 map 的 value 本身是不可寻址的


# 依赖管理
Go语言依赖管理经历了3个重要解读那。
- GOPATH：早期，不方便管理依赖的多个版本
- vendor：项目依赖同源代码一起管理，GO1.6后，可以理解为项目依赖位于本项目的vendor目录中（私有的GOPATH目录），项目编译先从vendor中寻找，若找不到，再到GOPATH中寻找。
  - 搜索顺序：从源码文件所在目录逐级向上搜索。
  - vendor过于分散，可能导致同一依赖包在项目的多个vendor中出现多次，编译二进制文件急剧增大。
  - 项目依赖关系不清晰。
  - 依赖包升级时不方便审核。
- Go Mondule：Go1.11开始引入，Go1.14以后，全新依赖管理工具
  - 准确记录项目依赖：通过Go Module指定package版本
  - 可重复构建：平台无关性

1. GOROOT和GOPATH
   - GOROOT：GO语言安装目录的环境变量，GO语言顶级目录
   - GOPATH：指向用户域，用户项目需要位于GOPATH目录下的src/目录中
     - GO语言项目由一个或多个package组成，按照来源可分为：
       - 标准库：位于GOROOT环境变量目录
       - 第三方库
       - 项目私有库
     - 某个package需要引用其他包时，依次从GOROOT和GOPATH目录下寻找
  
# 为什么是Golang
Golang的特性：
和Java的比较：
和Cpp的比较：

Golang云原生：

# 常见数据结构实现原理

## 管道 channel
1. 初始化
	- 变量声明
		```go
		var ch chan int
    ```
    声明的管道值为nil，每个管道只能存储一种类型数据。
	- 内置函数`make()`
    ```go
    ch1 := make(chan string) // 无缓冲管道
    ch2 := make(chan string, 5) // 带缓冲管道
    ```
2. 数据读写
  - 管道没有缓冲区时，从管道读取数据会阻塞，直到有协程向管道写入数据。同样写入数据也会阻塞。
  - 管道有缓冲区时，从管道读取数据如果缓冲区没有数据也会阻塞，写入数据时管道已满也会阻塞。
  - 值为nil的管道无论读写都会阻塞，而且是永久阻塞。
  - close可以关闭管道，向关闭的管道写入数据会触发panic。
3. 内置函数len和cap分别用于查询缓冲区数据个数和缓冲区大小。
4. 管道实现了FIFO先进先出队列，数据按照写入的顺序流出管道。
5. 阻塞条件：
  - 读管道：
    - 管道无缓冲区
    - 管道缓冲区无数据
    - 管道为nil
  - 写管道：
    - 管道无缓冲区
    - 管道缓冲区已满
    - 管道为nil
6. 实现原理
```go
type hchan struct {
  qcount uint // 剩余元素个数
  dataqsiz uint // 环形队列长素
  buf unsafe.Pointer // 环形队列指针
  elemsize uint16 // 每个元素大小
  
}
```
  
## 切片 slice
## map
# 常见包原理

# 协程

# 内存管理

# 并发控制

# 异常处理

# 反射

# 测试

# 定时器

# 泛型

# 语法糖

# 编程陷阱

# Go新特性
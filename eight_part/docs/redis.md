# Redis

## 基础
1. 什么是Redis

Redis是一个**内存数据结构**存储，用作数据库、缓存、消息代理和流引擎。

Redis提供字符串、散列（hash）、列表、集合、带范围的排序集合、位图、超日志、地理空间索引和流（Transactions）等数据结构。

内置了复制、Lua脚本、LRU追逐、事务和不同级别的磁盘持久性。

**特性**：
- 读写速度快：内存数据库，读写操作都在内存中完成。常用于缓存、消息队列、分布式锁等场景。
- 支持多种数据结构：如string、hash、list、set、zset、bitmaps、hyperloglog、geo、stream，且数据操作都是原子性的。

2. Redis和Memcached的区别
**共同点**
- 内存数据库
- 都有过期策略
- 高性能

**区别**
- 支持数据类型
  - Redis：string/hash/set/zset/list/geo/hyperloglog/stream/bitmap
  - Memcached：key-value
- 持久化
  - Redis：支持RDB和AOF两种持久化方式
  - Memcached：不支持持久化
- 集群
  - Redis：原生支持主从复制和集群
  - Memcached：不支持集群，但支持分布式。主要依靠客户端来实现忘集群中分片写入数据。
- 发布订阅
  - Redis：支持，还有Lua脚本、事务等功能
  - Memcached：不支持

3. 为什么Redis作为Mysql的缓存
- 高性能：Redis直接从内存中读取，Mysql从磁盘中读取，第一次读取后缓存到Redis中，速度快。
- 高并发：单机QPS是Mysql的十倍，能够破10w。而Mysql很难破1w。
  

4. 数据结构
**基础数据结构**
- string：字符串、整数、浮点数，对于整数和浮点数可以进行自增或自减操作；**缓存对象、常规计数、分布式锁、共享session信息等。**
- hash：无序，添加、获取和删除单个元素；**缓存对象、购物车等。**
- list：链表，push和pop，根据值查找；消息队列（**但是有两个问题，生产者需要自行实现全局唯一ID，不能以消费组形式消费数据**）
- set：无序，添加、获取、删除，计算交集、并集、差集等；**点赞、共同关注、抽奖活动等；**
- zset：和hash一样，用于存储键值对。字符成员与浮点数分数的有序映射，元素排列顺序由分数大小确定。添加、获取、删除和范围查询；**排序场景。**

**高级数据结构**
- bitmap：二值状态统计场景。签到、判断用户登录状态、连续签到用户总数等；
- hyperloglog：基数统计，可以用来统计网页的UV（独立访客）。
- geo：存储地理位置信息，并对存储的信息进行操作，如计算两个地点的距离，范围查询等。
- stream：消息队列，自动生成全局唯一消息ID，支持以消费组形式消费数据。

5. Redis数据类型的实现
**String类型**
- 底层数据结构：简单动态字符串（SDS）
- 相比于C的原生字符串
  - 不仅可以保存文本数据，也可以保存二进制数据。SDS使用len属性的值而不是空字符串来判断字符串是否结束。
    SDS的所有API都以处理二进制的方式处理buf数组。这也是SDS能够存储二进制数据（图片、音频、视频、压缩文件）等的原因。
  - 获取字符串长度的复杂度是O(1)。有len属性记录长度。
  - SDS API是安全的，字符串拼接不会造成缓冲区移除。在拼接之前会进行检查，如果空间不足，会先进行内存重分配。

**List类型**
- 底层数据结构：**双向链表**或**压缩列表**
> 什么是压缩列表？
> 表中每个节点都记录前一个节点的长度，使用指针偏移快速定位。使用连续的内存空间。
- 如果列表元素小于512个，列表每个元素值都小于64字节，列表使用压缩列表。
- 如果不满足，则使用双向链表。
> Redis 3.2后，List底层数据结构替换为quicklist。

**Hash类型**
- 底层数据结构：**压缩列表**或**哈希表**
- 如果哈希类型元素小于512个，列表每个元素值都小于64字节，列表使用压缩列表。
- 如果哈希类型元素不满足上面条件，Redis 会使用哈希表作为 Hash 类型的底层数据结构。
> 在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。

**Set类型**
- 底层数据结构：**哈希表**或 **整数集合**
- 如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用**整数集合**作为 Set 类型的底层数据结构；
- 如果集合中的元素不满足上面条件，则 Redis 使用哈希表作为 Set 类型的底层数据结构。

**ZSet类型**
- 底层数据结构：**压缩列表**或**跳表**
- 如果有序集合的元素个数小于 128 个，有序集合的成员个数小于 64 个，Redis 会使用**压缩列表**作为有序集合的底层数据结构；
- 如果有序集合的元素不满足上面的条件，Redis 会使用跳表作为 Zset 类型的底层数据结构；
> 在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。

6. Redis是单线程吗？
**Redis单线程指的是什么？**

Redis单线程指的是「接收客户端请求——>解析请求——>对数据进行读写操作——>发送数据给客户端」这个过程是由一个线程（主线程）来完成的。

但是Redis程序不是单线程的，Redis在启动时，会启动后台线程BIO。

- Redis的2.6版本，会启动2个后台线程，分别处理关闭文件/AOF刷盘两个任务；
- Redis的4.0版本，新增后台线程用于异步释放Redis内存，也就是lazyfree线程。例如执行 unlink key / flushdb async / flushall async 等命令，会把这些删除操作交给后台线程来执行，好处是不会导致 Redis 主线程卡顿。因此，当我们要删除一个大 key 的时候，不要使用 del 命令删除，因为 del 是在主线程处理的，这样会导致 Redis 主线程卡顿，因此我们应该使用 **unlink** 命令来异步删除大key。

之所以 Redis 为「**关闭文件、AOF 刷盘、释放内存**」这些任务创建单独的线程来处理，是因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。

后台线程相当于一个**消费者**，生产者把耗时任务丢到任务队列中，消费者（BIO）不停轮询这个队列，拿出任务就去执行对应的方法即可。

![](./Pasted%20image%2020240514174811.png)

- BIO_CLOSE_FILE：关闭文件任务队列，当队列有任务后，后台线程会调用 close(fd) ，将文件关闭；
- BIO_AOF_FSYNC：AOF 刷盘任务队列，当队列有任务后，后台线程会调用 fsync(fd) ，将 AOF 文件刷盘；
- BIO_LAZY_FREE：释放内存任务队列，当队列有任务后，后台线程会调用 free(obj)释放对象/free(dict)删除数据库所有对象/free(skiplist)释放跳表对象；

7. Redis单线程模式是怎样的？
![](./Pasted%20image%2020240514202442.png)

蓝色部分是主事件循环，由主线程负责，网络IO和命令都是单线程。

Redis初始化会做下面几件事情：
- 调用`epoll_create`创建一个epoll对象，调用`socket()`创建一个服务端socket。
- 调用`bind()`绑定端口，调用`listen()`监听该socket；
- 将调用`epoll_ctl()`将`listen socket`加入到epoll，同时注册连接事件处理函数。

初始化完毕后，主线程进入到事件循环函数：
- 调用**发送队列处理函数**，查看发送队列是否有任务，如果有，则通过write函数将客户端发送缓存区中的数据发送出去。如果这一轮数据没有发完，则注册**写时间处理函数**，等待epoll_wait发现可写后再处理。
- 调用epoll_wait函数等待时间到来：
  - **连接事件**：调用连接事件处理函数，调用accept获取已连接的socket——>调用epoll ctl将已连接的socket加入epoll——>注册「读事件」处理函数；
  - **读事件**：调用读事件处理函数，调用 read 获取客户端发送的数据 -> 解析命令 -> 处理命令 -> 将客户端对象添加到发送队列 -> 将执行结果写到发送缓存区等待发送；
  - **写事件**：调用写事件处理函数，通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会继续注册写事件处理函数，等待 epoll_wait 发现可写后再处理。

8. Redis采用单线程为什么还那么快？
- 纯内存操作，绝大部分请求是纯粹的内存操作，非常快速。Redis的瓶颈可能是机器的内存或网络带宽，而非CPU。
- 单线程避免了多线程之间的竞争，省去了多线程切换带来的时间和性能上的开销。
- IO多路复用处理客户端Socket请求。

**IO多路复用**

也就是select/epoll机制。在Redis只运行单线程的情况下，IO多路复用允许内核中，同时存在多个监听Socket和已连接Socket。内核会一直监听这些Socket上的连接情况，一旦有请求到达，就会交给Redis处理。也就实现了一个Redis线程处理多个IO流的效果。

9. Redis 6.0 之前为什么使用单线程？

**CPU并不是制约Redis性能瓶颈所在**，更多情况是受到内存大小和网络IO的限制。

如果要使用服务的多核CPU，可以在一台服务器上启动多个Redis实例，每个实例使用不同的端口。

**多线程会带来的问题**
- 资源竞争
- 线程切换开销
- 系统复杂度增加
- 加锁解锁、死锁带来的损耗

10. Redis 6.0 之后为什么使用多线程？

**Redis对于网络IO采用多线程处理，但是对于命令的执行，仍然是单线程。**

Redis 6.0 版本支持的 I/O 多线程特性，默认情况下 I/O 多线程**只针对发送响应数据**（write client socket），并不会以多线程的方式处理读请求（read client socket）。要想开启多线程处理客户端读请求，就需要把 Redis.conf 配置文件中的 io-threads-do-reads 配置项设为 yes。

Redis在启动时，除了主线程外，还会额外创建6个线程：
- Redis-server：Redis主线程，主要负责执行命令；
- bio_close_file、bio_aof_fsync、bio_lazy_free：三个后台线程，分别异步处理关闭文件任务、AOF刷盘任务、释放内存任务；
- io_thd_1、io_thd_2、io_thd_3：三个 I/O 线程，io-threads 默认是 4 ，所以会启动 3（4-1）个 I/O 多线程，用来分担 Redis 网络 I/O 的压力。

11. Redis如何保证数据不丢失？

Redis的持久化机制：
- AOF日志：每执行一条**写操作命令**，就把该**命令**以追加方式写入到一个文件里；
- RDB快照：将某一时刻的**内存数据**，以二进制的方式写入到磁盘里。
- 混合持久化：将快照和AOF日志混合使用。

12. AOF日志是如何实现的？
 
Redis在**执行完**一条写操作后，会将命令以**追加方式**写入到一个文件中。

Redis重启时，会读取该文件记录的命令，逐一执行进行数据恢复。

**先执行写操作，再写AOF。**

![](./Pasted%20image%2020240514204745.png)

**好处**
- **避免额外的检查开销**：防止错误命令记录；
- **不会阻塞当前写命令的执行**。

**风险**
- **数据可能丢失**：写完宕机；
- **阻塞其他操作**：AOF也是在主线程中执行。

![](./Pasted%20image%2020240514205016.png)

其中，「*3」表示当前命令有三个部分，每部分都是以「$+数字」开头，后面紧跟着具体的命令、键或值。然后，这里的「数字」表示这部分中的命令、键或值一共有多少字节。例如，「$3 set」表示这部分有 3 个字节，也就是「set」命令这个字符串的长度。

**AOF写回策略**
![](./Pasted%20image%2020240514212944.png)

- Redis执行完写操作命令后，会将命令追加到server.aof_buf缓冲区；
- 通过write系统调用，将aof_buf缓冲区的数据写入到AOF文件，此时数据并没有写入到磁盘，而是拷贝到了内核缓冲区page cache（写入到页缓存），等待内核将数据写入硬盘；
- 由内核发起写操作，完成刷盘。

`appendsync`配置写回策略：
- always：同步写回；**可靠性最高，最大程度保证不丢失**
- everysec：每秒写回；**性能适中**
- no：交给操作系统决定何时写回。**性能好**

**AOF日志过大，会触发什么机制**

AOF日志过大，重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。

Redis 为了避免 AOF 文件越写越大，提供了 AOF 重写机制，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来**压缩 AOF 文件**。

重写机制：
- AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。
- 重写后减少AOF文件的大小，使其记录都是最新的。

**重写AOF日志的过程**

Redis的重写AOF过程是由后台子进程`bgrewriteaof`完成的，有下面几个好处：
- 子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而**避免阻塞主进程**；
- 子进程带有主进程的数据副本，（这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。）创建子进程时，父子进程共享内存数据，不过只能是**只读**方式，当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本（创建新的内存页，而不直接修改共享页），就不用加锁来保证数据安全。

触发重写机制后，**主进程就会创建重写 AOF 的子进程，此时父子进程共享物理内存**，重写子进程只会对这个内存进行只读，重写 AOF 子进程会读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志（新的 AOF 文件）。

在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会同时将这个写命令写入到 **「AOF 缓冲区」**和 **「AOF 重写缓冲区」**。

![](./Pasted%20image%2020240514214642.png)

子进程完成AOF重写工作后，会向主进程发送信号（异步通信），主进程收到信号后：
- AOF重写缓冲区的内容追加到AOF文件中，使得新旧AOF文件数据状态一致；
- 新的AOF文件进行改名，覆盖现有的AOF文件。

13.  RDB快照是如何实现的？

相比于AOF，RDB记录瞬时的数据库状态（实际数据）。RDB提供了两个命令，分别是save和bgsave，区别在于是否在主线程中执行。

- save：会阻塞主线程，直到RDB文件创建完毕为止。
- bgsave：会派生一个子进程，可以避免主线程的阻塞。

Redis可以配置定时执行bgsave命令。

**RDB的快照类型**

全量快照，每次执行快照，都将内存中的所有数据记录到磁盘中。

执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。

bgsave执行过程中同样采用了「写时复制」技术。

创建子进程时，会复制页表。

如果主线程执行写操作，则被修改的数据会复制一份副本，然后 bgsave 子进程会**把该副本数据写入 RDB 文件**，在这个过程中，主线程仍然可以直接修改原来的数据。

14. 为什么使用混合持久化？

集成了RDB和AOF的优点。

- RDB：数据恢复速度快，但是快照的频率不好把握；
- AOF：丢失数据少，但是数据恢复慢；

- 子进程以RDB格式写入内存数据：当开启混合持久化并触发AOF重写时，Redis会创建一个子进程。这个子进程首先**将内存中的数据以RDB格式写入到新的AOF文件中。** RDB是一个紧凑的二进制格式，它非常快地保存和恢复数据，但不支持实时持久化。
- 主进程记录**增量命令**：在子进程进行RDB写入的同时，主进程继续处理客户端的命令请求。这些命令会被写入到一个重写缓冲区（aof_rewrite_buf_blocks），而不是直接写入旧的AOF文件。
- **增量命令以AOF格式写入**：当子进程完成RDB数据的写入后，它会将重写缓冲区中的增量命令以AOF格式追加到新的AOF文件中。这些增量命令是在子进程创建后主进程处理的，它们确保了从子进程创建时刻到AOF重写完成时刻的数据一致性。
- 新AOF文件替换旧文件：一旦子进程完成了RDB和AOF格式的写入，它会通知主进程。主进程会在下一次fsync操作时，将新的含有RDB格式快照和AOF格式增量命令的AOF文件替换旧的AOF文件。

也就是说，使用了混合持久化，AOF文件的**前半部分是RDB格式**的全量数据，**后半部分是AOF格式**的增量数据。

**混合持久化优点**：
- 混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。

**混合持久化缺点**：
- AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；
- 兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。

## 过期删除和内存淘汰

15. Redis使用的过期删除策略是什么？

Redis可以对key设置过期时间，当对key设置了过期时间时，Redis会将key和expire time存储到**过期字典**中。过期字典保存了数据库中所有key的过期时间。

**查询key的流程**
- 检查key是否在过期字典中；
- 不在：正常读取键值；
- 存在：获取该key的过期时间，与系统时间进行比对，判定是否过期；

**过期键的删除策略**

**惰性删除策略**

不主动删除，每次从数据库访问key时，都检测key是否过期，如果过期则删除（和实现的bitcask-go类似）

- 优点：请求时才删除，系统资源占用少。
- 缺点：内存空间浪费。

**定期删除策略**

每隔一段时间**随机**从数据库取出一定量的key进行检查，并删除其中的过期key。

流程：
- 随机抽取20个key；
- 检查是否过期，删除已过期的key；
- 如果占比>25%，则重复抽取和删除，否则等待下一轮检查（确保不会循环过度）

- 优点：通过限制删除操作执行的时长和频率，减少删除操作对CPU的影响，同时删除一部分过期的数据，减少过期key的空间浪费。
- 缺点：难以确定删除操作执行的时长和频率。

16. Redis持久化时，对过期键是如何处理的？

**RDB**
- 文件生成阶段：对key进行检查，过期的key不会写入到RDB中；
- 文件加载阶段：
  - 主服务器运行：过期key不会被加载；
  - 从服务器运行：过期key会被加载，无论是否过期。但是进行主从同步时，从服务器的数据会被清空。所以也没有影响。

**AOF**
- 文件写入阶段：追加DEL命令显示删除；
- 文件重写阶段：不会被重写。

17. Redis主从模式中，对过期键如何处理？
从库不会进行过期扫描，从库对过期的处理是被动的。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。

从库的过期键处理依靠主服务器控制，主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指令来删除过期的 key。

18. Redis内存满了，会发生什么？

触发内存淘汰机制，阈值为maxmemory。

19. Redis内存淘汰策略有哪些？
**不进行数据淘汰的策略**
- noeviction：不淘汰任何数据，而是不再提供服务，直接返回错误。

**进行数据淘汰的策略**
- 在设置了过期时间的数据中进行淘汰
  - volatile-random
  - volatile-ttl
  - volatile-lru：最久未使用
  - volatile-lfu：最少使用
- 在所有数据范围内进行淘汰
  - allkeys-random
  - allkeys-lru
  - allkeys-lfu

20. LRU算法和LFU算法的区别？
**LRU算法**

LRU，Least Recently Used，最近最少使用，淘汰最近最少使用的数据。

传统的LRU的实现是基于**链表**结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头。需要内存淘汰时，只需要删除尾部元素即可。（尾部为最久未使用）。

但是Redis并没有这么实现LRU算法，原因是：
- 链表的实现需要额外的内存空间，Redis使用的是**字典**结构，字典的实现是哈希表。
- 有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，降低性能。

Redis的LRU实现：
- 在Redis对象中添加一个额外字段，记录此数据最后一次访问时间；
- 随机采样，随机取5个值，淘汰最久未使用的。

优点：
- 不用维护大链表，节省空间占用；
- 不用每次访问数据都移动链表项，提升了缓存的性能。

缺点：
- 无法解决缓存污染问题。

**LFU算法**

LFU，Least Frequently Used，最近最不常用的。

**如果数据过去被访问多次，那么将来被访问的频率也更高。**

## 事务

Redis支持简单的事务，可以将多个命令打包，然后一次性地按顺序执行。

主要通过multi、exec、discard、watch等命令实现。

- multi：事务块的开始
- exec：执行所有事务块
- discard：取消事务，放弃执行事务块内的所有命令
- watch：监视一个或多个key，如果在事务执行之前这个key被其他命令所改动，那么事务将被打断。

**Redis事务的原理**
- multi命令开始一个事务。从这个命令执行之后开始，所有的后续命令都不会立即执行，而是被放入一个**队列**中。在这个阶段，Redis只是记录下了这些命令。
- exec命令触发事务执行。atomic执行。
- 如果在exec之前决定不执行，使用discard取消事务。清空事务队列并退出事务状态。
- watch用于乐观锁。

**Redis事务不支持回滚**

Redis 事务是不支持回滚的，不像 MySQL 的事务一样，要么都执行要么都不执行；一旦 EXEC 命令被调用，所有命令都会被执行，即使有些命令可能执行失败。失败的命令不会影响到其他命令的执行。

Redis 中并没有提供回滚机制，虽然Redis提供了discard命令，但是这个命令只能用来主动放弃事务执行，把暂存的命令队列清空，起不到回滚的效果。

引入事务回滚机制会大大增加 Redis 的复杂性，因为需要跟踪事务中每个命令的状态，并在发生错误时逆向执行命令以恢复原始状态。

Redis 是一个基于内存的数据存储系统，其设计重点是实现高性能。事务回滚需要额外的资源和时间来管理和执行，这与 Redis 的设计目标相违背。因此，Redis 选择不支持事务回滚。
# 自我介绍

# 操作系统
**为什么要有虚拟内存**
- 程序执行时的地址的地址和实际物理地址不同，在不同进程之间的地址隔离开来。虚拟地址通过CPU中的MMU单元转换成物理地址。
- 虚拟地址实现内存扩容，操作系统换入换出，如何映射，段页式，段号，段内偏移量。通过段表与物理地址进行映射。分段可能会产生内存碎片问题。linux的swap空间就是从硬盘中划分出来的，用于内存和硬盘的空间交换。
- Linux的虚拟空间分布可分为用户态和内核态，用户态有代码段、全局变量、函数栈、堆内存、映射区。

虚拟内存的作用
- 程序局部性原理，进程对运行内存超过物理大小，换入换出；
- 隔离进程的内存空间；
- 控制页表读写权限。

**内存满了，会发生什么**

内存回收
- 后台内存回收：唤醒内核线程回收内存
- 直接内存回收：后台异步回收跟不上内存申请的速度，直接开始回收，同步，会阻塞进程的执行

可被回收的
- 文件也
- 匿名页

回收都是基于LRU算法，优先回收不常访问的内存。

**进程、线程、协程**

状态：运行、就绪、阻塞

PCB进程控制块，进程存在的唯一标识。

进程标识符，进程控制和管理信息，优先级，资源分配清单（地址空间，打开文件列表，设备IO信息），CPU相关信息，CPU中寄存器的值，进程切换时，CPU的状态信息保存在PCB中，以便进程重新执行时，能够从断点处继续执行。

PCB通过链表组织在一起。有就绪队列、阻塞队列等。

进程的上下文切换，将前一个进程的CPU上下文保存起来（CPU计数器和程序计数器），然后加载新任务的上下文到这些寄存器和程序计数器。

系统内核会存储保存的上下文信息，再次分配给CPU执行时，CPU会重新加载这些上下文，保证任务原来的状态不受影响。

CPU上下文切换分为：
- 进程上下文切换：虚拟内存、栈、全局变量等用户空间资源，还包括内存堆栈、寄存器等内核空间资源
- 线程：寄存器、私有数据等不共享资源
- 中断

线程和进程的比较：
- 进程：资源分配单位
- 线程：CPU调度单位，创建时间快，终止快，不需要切页表，共享内存


**进程间的通信方式**
- 管道：内核的一串缓存。fork创建的子进程会复制父进程的文件描述符，只能单向通信。不适合进程间频繁交换数据。
- 消息队列：内核中的消息链表。
- 共享内存
- 信号量：实现互斥和同步，PV操作
- 信号：一步通信方式
- socket：跨网络通信

**死锁**
- 互斥
- 持有并等待
- 不可剥夺
- 循环等待

资源有序分配法

**乐观锁和悲观锁**
悲观锁认为在访问共享资源时，冲突的概率非常高，在开始访问时之前进行加锁。

乐观锁不显式加锁，而是在访问后，通过版本号或时间戳判断这段时间内有没有发生冲突。

**互斥锁和自旋锁**

互斥锁是一种独占锁，加锁失败会释放CPU；

自旋锁加锁失败后，会忙等，直到拿到锁。

**一个进程最多可以创还能多少线程**

- 进程的虚拟内存空间上限
- 系统参数限制

**线程崩溃了，进程一定崩溃吗**

- 地址空间是共享的，非法访问会造成内存不确定性，进而影响到其他线程，非常危险

**零拷贝**

DMA

CPU发出对应指令给磁盘控制器，然后返回

磁盘控制器收到指令后，开始准备数据，将数据发送到磁盘控制器的内部缓冲区，产生中断

CPU收到中断信号后，停下手头的工作，读取缓冲区内容到寄存器，写入内存


# 网络

# 数据库

# SQL语句

# golang
channel上下游如何通信。

在发送和接收之间进行同步。

channel分为有缓冲channel和无缓冲channel，无缓冲channel必须先读后写，当上游channel试图向channel发送值时，会阻塞，直到下游goroutine准备好接收。

有缓冲channel，不需要数据立即被接收。通信可以异步。

关闭channel实际是不再发送任何值，但是仍然可以读取之前已发送的值。

select语句：允许多个goroutine同时等待多个channel，用于同时监听多个上游channel。

# Redis
Redis百万个key，去get有什么问题
- Redis是一个内存数据库，考虑内存瓶颈，淘汰策略处理内存不足；
- 大量key进行读取操作，批量操作减少网络IO，提升效率；
- 网络延迟；
- 数据一致性和持久性，适当的持久化配置；
- 键的管理和监控，如Redis的性能指标；
- 并发控制，使用连接池；

# Linux

# 场景题

对IO密集交互，核心数增加可以带来
- 并发处理能力提升
- 负载均衡
- IO等待时间的减少，CPU等待IO操作完成时会处于空闲状态，增加核心数可以在一个核心等待IO时，处理其他任务。

但还需要考虑
- 内存带宽
- 上下文切换开销
- 软件优化
- 成本考虑

并发加锁查询有哪些锁
- 乐观锁
- 悲观锁
- 读写锁
- 分布式锁

# 算法题
```cpp
int findMax(vector<int>& nums) {
    int left = 0;
    int right = nums.size() - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] > nums[mid+1]) {
            // 最大值在mid的左侧
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return nums[left];
}
```

```go
// 多线程顺序打印
// 使用channel同步goroutine
func main() {
    var wg sync.WaitGroup   // 等待所有goroutine完成
    ch := make(chan bool)   // 在goroutine之间同步
    for i := 'A'; i < 'C'; i++ {
        wg.Add(1)
        go func(char rune) {
            defer wg.Done()
            <- ch;
            fmt.Printf("%c ", char)
            ch <- true
        }(rune(i))
    }
    ch <- true
    wg.Wait()
}
```

**自我介绍**

面试官您好，我叫任思怡，今年22岁，目前是华中科技大学计算机学院的一名研二学生，预计明年6月毕业。本科就读于华中师范大学计算机学院，我本科硕士期间参加过一些数学建模竞赛，主要负责建模和编程，拿过全国大学生数模竞赛二等奖和研究生数学建模竞赛三等奖。硕士期间做了一些深度学习相关的工作，主要面向半监督学习的工业缺陷检测。我是一个比较乐观开朗的人，喜欢尝试新事物，平时喜欢骑车和摄影，以及参加志愿服务活动，曾经担任武汉马拉松志愿者。以上就是我的自我介绍，非常感谢有这次面试机会，谢谢~